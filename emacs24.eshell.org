* Helper functions
#+BEGIN_SRC emacs-lisp :tangle yes
;; -*- lexical-binding: t; -*-

  ;; Cache for git status to avoid running shell commands on every keystroke
  (defvar eshell-git-status-cache nil
    "Cache for git status info. Alist of (directory . (branch unstaged uncommitted timestamp)).")

  (defvar eshell-git-status-cache-ttl 5
    "Time-to-live in seconds for git status cache entries.")

  (defun eshell-git-status-cache-valid-p (pwd)
    "Check if cache entry for PWD is still valid."
    (when-let ((entry (assoc pwd eshell-git-status-cache)))
      (let ((timestamp (nth 4 (cdr entry))))
        (< (- (float-time) timestamp) eshell-git-status-cache-ttl))))

  (defun eshell-git-status-cache-get (pwd)
    "Get cached git status for PWD, or nil if not cached/expired."
    (when (eshell-git-status-cache-valid-p pwd)
      (cdr (assoc pwd eshell-git-status-cache))))

  (defun eshell-git-status-cache-set (pwd branch unstaged uncommitted)
    "Cache git status for PWD."
    (setq eshell-git-status-cache
          (cons (cons pwd (list branch unstaged uncommitted (float-time)))
                (assq-delete-all pwd eshell-git-status-cache))))

  (defun eshell-git-status-update (pwd)
    "Update git status cache for PWD. Returns (branch unstaged uncommitted)."
    (if (and (eshell-search-path "git")
             (locate-dominating-file pwd ".git"))
        (let* ((branch (let ((git-output (shell-command-to-string
                                          "git branch --show-current 2>/dev/null")))
                         (if (> (length git-output) 0)
                             (concat "[" (string-trim git-output) "]")
                           "[detached]")))
               (unstaged (let ((git-output (string-trim
                                            (shell-command-to-string
                                             "git diff --numstat 2>/dev/null | wc -l"))))
                           (let ((n (string-to-number git-output)))
                             (cond ((= n 1) "1 unstaged change")
                                   ((> n 1) (format "%d unstaged changes" n))
                                   (t "")))))
               (uncommitted (let ((git-output (string-trim
                                               (shell-command-to-string
                                                "git diff --cached --numstat 2>/dev/null | wc -l"))))
                              (let ((n (string-to-number git-output)))
                                (cond ((= n 1) "1 uncommitted change")
                                      ((> n 1) (format "%d uncommitted changes" n))
                                      (t ""))))))
          (eshell-git-status-cache-set pwd branch unstaged uncommitted)
          (list branch unstaged uncommitted))
      (list nil "" "")))

  (defun eshell-get-git-status (pwd)
    "Get git status for PWD, using cache if available."
    (or (eshell-git-status-cache-get pwd)
        (eshell-git-status-update pwd)))

  (defun fish-path (path max-len)
    "Return a potentially trimmed-down version of the directory PATH, replacing
  parent directories with their initial characters to try to get the character
  length of PATH (sans directory slashes) down to MAX-LEN."
    (let* ((components (split-string (abbreviate-file-name path) "/"))
           (len (+ (1- (length components))
                   (cl-reduce '+ components :key 'length)))
           (str ""))
      (while (and (> len max-len)
                  (cdr components))
        (setq str (concat str
                          (cond ((= 0 (length (car components))) "/")
                                ((= 1 (length (car components)))
                                 (concat (car components) "/"))
                                (t
                                 (if (string= "."
                                              (string (elt (car components) 0)))
                                     (concat (substring (car components) 0 2)
                                             "/")
                                   (string (elt (car components) 0) ?/)))))
              len (- len (1- (length (car components))))
              components (cdr components)))
      (concat str (cl-reduce (lambda (a b) (concat a "/" b)) components))))

  ;; (setq eshell-prompt-function
  ;;   (lambda ()
  ;;     (concat (fish-path (eshell/pwd) 3 ) (if (= (user-uid) 0) " # " " $ "))))

  (defmacro with-face (str &rest properties)
    `(propertize ,str 'face (list ,@properties)))

  ;; Legacy functions removed - now using cached eshell-get-git-status instead

  (defun shk-eshell-prompt ()
    (let* ((pwd (eshell/pwd))
           (git-status (eshell-get-git-status pwd))
           (shk-git-branch (nth 0 git-status))
           (shk-git-unstaged-changes (nth 1 git-status))
           (shk-git-uncommitted-changes (nth 2 git-status)))
      (concat
       (if (boundp 'venv-current-name)
           (with-face (if (> (length venv-current-name) 0)
                          (concat "(" venv-current-name ") ") "") :foreground "#8592F2")
         "")
       (with-face (concat (eshell/pwd) " ") )
       (with-face (format-time-string "(%Y-%m-%d %H:%M) " (current-time)) :foreground "#AAA")
       (with-face
        (format "%s%s%s"
                (or shk-git-branch "")
                (if (> (length shk-git-unstaged-changes) 0)
                    (concat " - " shk-git-unstaged-changes) "")
                (if (> (length shk-git-uncommitted-changes) 0)
                    (concat " - " shk-git-uncommitted-changes) ""))

        :foreground "yellow")
       (with-face "\n" )
       (with-face user-login-name :foreground "blue")
       "@"
       (with-face (first (split-string (system-name) "\\.")) :foreground "green")
       (if (= (user-uid) 0)
           (with-face " #" :foreground "red")
         " $")
       " ")))


  (defun eshell/emacs (&rest args)
    "Open a file in emacs. Some habits die hard."
    (if (null args)
        ;; If I just ran "emacs", I probably expect to be launching
        ;; Emacs, which is rather silly since I'm already in Emacs.
        ;; So just pretend to do what I ask.
        (bury-buffer)
      ;; We have to expand the file names or else naming a directory in an
      ;; argument causes later arguments to be looked for in that directory,
      ;; not the starting directory
      (mapc #'find-file
            (mapcar #'expand-file-name
                    (flatten-tree (reverse args))))))


  ;;(add-to-list 'ac-modes 'eshell-mode)

  (defun ac-pcomplete ()
    ;; eshell uses `insert-and-inherit' to insert a \t if no completion
    ;; can be found, but this must not happen as auto-complete source
    (cl-flet ((insert-and-inherit (&rest args)))
      ;; this code is stolen from `pcomplete' in pcomplete.el
      (let* (tramp-mode ;; do not automatically complete remote stuff
             (pcomplete-stub)
             (pcomplete-show-list t) ;; inhibit patterns like * being deleted
             pcomplete-seen pcomplete-norm-func
             pcomplete-args pcomplete-last pcomplete-index
             (pcomplete-autolist pcomplete-autolist)
             (candidates (pcomplete-completions))
             (beg (pcomplete-begin))
             ;; note, buffer text and completion argument may be
             ;; different because the buffer text may bet transformed
             ;; before being completed (e.g. variables like $HOME may be
             ;; expanded)
             (buftext (buffer-substring beg (point)))
             (arg (nth pcomplete-index pcomplete-args)))
        ;; we auto-complete only if the stub is non-empty and matches
        ;; the end of the buffer text
        (when (and (not (zerop (length pcomplete-stub)))
                   (or (string= pcomplete-stub ; Emacs 23
                                (substring buftext
                                           (max 0
                                                (- (length buftext)
                                                   (length pcomplete-stub)))))
                       (string= pcomplete-stub ; Emacs 24
                                (substring arg
                                           (max 0
                                                (- (length arg)
                                                   (length pcomplete-stub)))))))
          ;; Collect all possible completions for the stub. Note that
          ;; `candidates` may be a function, that's why we use
          ;; `all-completions`.
          (let* ((cnds (all-completions pcomplete-stub candidates))
                 (bnds (completion-boundaries pcomplete-stub
                                              candidates
                                              nil
                                              ""))
                 (skip (- (length pcomplete-stub) (car bnds))))
            ;; We replace the stub at the beginning of each candidate by
            ;; the real buffer content.
            (mapcar #'(lambda (cand) (concat buftext (substring cand skip)))
                    cnds))))))

#+END_SRC


* Eshell
#+BEGIN_SRC emacs-lisp :tangle yes

  ;; Add keybindings
  (use-package eshell
    :commands (eshell helm-info-eshell helm-eshell-history
                      eshell-insert-buffer-name)
    :config
    (setq eshell-cmpl-cycle-completions nil
          ;; eshell-banner-message "..."
          eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'"
          eshell-highlight-prompt nil
          eshell-history-file-name "~/.bash_history"
          eshell-history-size nil
          eshell-prompt-function 'shk-eshell-prompt
          eshell-review-quick-commands nil
          eshell-save-history-on-exit t
          eshell-smart-space-goes-to-end t
          eshell-visual-commands '("vi" "screen" "top" "less" "more"
          "lynx" "ncftp" "ssh" "pine" "tin" "trn" "elm" "htop")
          eshell-where-to-jump 'begin
          pcomplete-cycle-completions nil))

  (add-hook 'eshell-mode-hook
            #'(lambda ()
                (smartparens-strict-mode 1)
                (rainbow-delimiters-mode 1)
                (setenv "PAGER" "cat")
                (smartscan-mode -1)
                (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)))

  (add-hook 'eshell-after-prompt-hook
            #'(lambda ()
                (rename-buffer (concat "eshell: " default-directory) t)))

#+END_SRC
